<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>libDataStruct: include/CLList.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.4 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li class="current"><a href="files.html"><span>Files</span></a></li>
  </ul>
</div>
<h1>include/CLList.h File Reference</h1>
<p>
<a href="CLList_8h-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLList__node__tab.html">CLList_node_tab</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCLList.html">CLList</a></td></tr>

<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef struct <a class="el" href="structCLList__node__tab.html">CLList_node_tab</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="CLList_8h.html#f840e66598cedab3029a5494025cbad9">CLList_node</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void *(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="CLList_8h.html#14195b0568a72a7b6703d5c5c082def5">CLList_iterate_func</a> )(<a class="el" href="structCLList.html">CLList</a> *list, <a class="el" href="structCLList__node__tab.html">CLList_node</a> *node, void *data, void *extra)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="CLList_8h.html#f6c6ca2fb5379cc18f8af44423622f2d">CLList_data_free_func</a> )(void *data)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void *(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="CLList_8h.html#3d605c8a96cd6648f2c8a48438efd6eb">CLList_data_copy_func</a> )(void **dest, void *src)</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structCLList__node__tab.html">CLList_node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="CLList_8h.html#5ead5ab5fb3450c753300ec7a7c44e68">CLList_append</a> (<a class="el" href="structCLList.html">CLList</a> *list, void *data)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structCLList__node__tab.html">CLList_node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="CLList_8h.html#430db45e90d081c4553bfa00198b7bab">CLList_insert_after</a> (<a class="el" href="structCLList.html">CLList</a> *list, <a class="el" href="structCLList__node__tab.html">CLList_node</a> *node, void *data)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structCLList__node__tab.html">CLList_node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="CLList_8h.html#61401e0395828f9b11ebb81e12dc58b8">CLList_insert_before</a> (<a class="el" href="structCLList.html">CLList</a> *list, <a class="el" href="structCLList__node__tab.html">CLList_node</a> *node, void *data)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="CLList_8h.html#35f655beb932d5685ed4adf55ba579d9">CLList_delete</a> (<a class="el" href="structCLList.html">CLList</a> *list, <a class="el" href="structCLList__node__tab.html">CLList_node</a> *node)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="CLList_8h.html#26b9eed51a08149d99a6ed6d6cd27f12">CLList_delete_after</a> (<a class="el" href="structCLList.html">CLList</a> *list, <a class="el" href="structCLList__node__tab.html">CLList_node</a> *node)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="CLList_8h.html#4f31db7585de0125e2e720292c98257d">CLList_delete_before</a> (<a class="el" href="structCLList.html">CLList</a> *list, <a class="el" href="structCLList__node__tab.html">CLList_node</a> *node)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="CLList_8h.html#a075ee2c83a1cc2378677dc04280cad9">CLList_length</a> (<a class="el" href="structCLList.html">CLList</a> *list)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="CLList_8h.html#e6e71ca1a8f11e148498a0ad30647d14">CLList_iterate</a> (<a class="el" href="structCLList.html">CLList</a> *list, <a class="el" href="CLList_8h.html#14195b0568a72a7b6703d5c5c082def5">CLList_iterate_func</a> function, void *extra)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="CLList_8h.html#406fb5b9723d9ddb6caa0aafdf27a327">CLList_delete_all</a> (<a class="el" href="structCLList.html">CLList</a> *list, <a class="el" href="CLList_8h.html#f6c6ca2fb5379cc18f8af44423622f2d">CLList_data_free_func</a> function)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="CLList_8h.html#3fa053da617f5c5a39a62ffeaeac69bd">CLList_rotate</a> (<a class="el" href="structCLList.html">CLList</a> *list, size_t nodes, int reverse)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="CLList_8h.html#776a86890036e203e4ce88181e9abc7d">CLList_append_list</a> (<a class="el" href="structCLList.html">CLList</a> *dest, <a class="el" href="structCLList.html">CLList</a> *src)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="CLList_8h.html#8e2cb7914972a92c26187178e71118af">CLList_insert_list_after</a> (<a class="el" href="structCLList.html">CLList</a> *dest, <a class="el" href="structCLList.html">CLList</a> *src, <a class="el" href="structCLList__node__tab.html">CLList_node</a> *node)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="CLList_8h.html#b1e4bb108f2c79fabb2396fb09d56891">CLList_insert_list_before</a> (<a class="el" href="structCLList.html">CLList</a> *dest, <a class="el" href="structCLList.html">CLList</a> *src, <a class="el" href="structCLList__node__tab.html">CLList_node</a> *node)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structCLList__node__tab.html">CLList_node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="CLList_8h.html#3bafa40bd49e3ea57ef0b5cb897fcf83">CLList_append_list_copy</a> (<a class="el" href="structCLList.html">CLList</a> *dest, <a class="el" href="structCLList.html">CLList</a> *src, <a class="el" href="CLList_8h.html#3d605c8a96cd6648f2c8a48438efd6eb">CLList_data_copy_func</a> copy_func)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structCLList__node__tab.html">CLList_node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="CLList_8h.html#1f8b819b54c62977d88f2fab9988d5a2">CLList_insert_list_after_copy</a> (<a class="el" href="structCLList.html">CLList</a> *dest, <a class="el" href="structCLList.html">CLList</a> *src, <a class="el" href="structCLList__node__tab.html">CLList_node</a> *node, <a class="el" href="CLList_8h.html#3d605c8a96cd6648f2c8a48438efd6eb">CLList_data_copy_func</a> copy_func)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structCLList__node__tab.html">CLList_node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="CLList_8h.html#49451808cf3a6da23d9eb256b4ed34d0">CLList_insert_list_before_copy</a> (<a class="el" href="structCLList.html">CLList</a> *dest, <a class="el" href="structCLList.html">CLList</a> *src, <a class="el" href="structCLList__node__tab.html">CLList_node</a> *node, <a class="el" href="CLList_8h.html#3d605c8a96cd6648f2c8a48438efd6eb">CLList_data_copy_func</a> copy_func)</td></tr>

</table>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="3d605c8a96cd6648f2c8a48438efd6eb"></a><!-- doxytag: member="CLList.h::CLList_data_copy_func" ref="3d605c8a96cd6648f2c8a48438efd6eb" args=")(void **dest, void *src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void*(* <a class="el" href="CLList_8h.html#3d605c8a96cd6648f2c8a48438efd6eb">CLList_data_copy_func</a>)(void **dest, void *src)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
type of function to pass to the copy functions<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>pointer to the new data pointer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>the data pointer in the node to be copyed</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the new new copyed data NULL on error</dd></dl>
note: that unfortunatly strcpy() CAN NOT be used here. you need to allocate memory and then use strcpy() 
<p>Definition at line <a class="el" href="CLList_8h-source.html#l00087">87</a> of file <a class="el" href="CLList_8h-source.html">CLList.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="f6c6ca2fb5379cc18f8af44423622f2d"></a><!-- doxytag: member="CLList.h::CLList_data_free_func" ref="f6c6ca2fb5379cc18f8af44423622f2d" args=")(void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="CLList_8h.html#f6c6ca2fb5379cc18f8af44423622f2d">CLList_data_free_func</a>)(void *data)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
type of a function to pass to the delete functions to free the data<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>pointer to the data to be free'ed</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>nothing</dd></dl>
note: free() can be used if the data is a simple type 
<p>Definition at line <a class="el" href="CLList_8h-source.html#l00070">70</a> of file <a class="el" href="CLList_8h-source.html">CLList.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="14195b0568a72a7b6703d5c5c082def5"></a><!-- doxytag: member="CLList.h::CLList_iterate_func" ref="14195b0568a72a7b6703d5c5c082def5" args=")(CLList *list, CLList_node *node, void *data, void *extra)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void*(* <a class="el" href="CLList_8h.html#14195b0568a72a7b6703d5c5c082def5">CLList_iterate_func</a>)(<a class="el" href="structCLList.html">CLList</a> *list, <a class="el" href="structCLList__node__tab.html">CLList_node</a> *node, void *data, void *extra)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
type of function to be passed to the iterate function<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>the</em>&nbsp;</td><td>list being parsed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>node</em>&nbsp;</td><td>the current node </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>the data the current node holds </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>extra</em>&nbsp;</td><td>the extra pointer passed to the itterate function</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>null to continue the itterate loop non null that stops the itterate loop and is returned by the iterate function </dd></dl>

<p>Definition at line <a class="el" href="CLList_8h-source.html#l00052">52</a> of file <a class="el" href="CLList_8h-source.html">CLList.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="f840e66598cedab3029a5494025cbad9"></a><!-- doxytag: member="CLList.h::CLList_node" ref="f840e66598cedab3029a5494025cbad9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structCLList__node__tab.html">CLList_node_tab</a>  <a class="el" href="structCLList__node__tab.html">CLList_node</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="5ead5ab5fb3450c753300ec7a7c44e68"></a><!-- doxytag: member="CLList.h::CLList_append" ref="5ead5ab5fb3450c753300ec7a7c44e68" args="(CLList *list, void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCLList__node__tab.html">CLList_node</a>* CLList_append           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCLList.html">CLList</a> *&nbsp;</td>
          <td class="paramname"> <em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
function to add a node to the tail of a circular linked list<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>list</em>&nbsp;</td><td>the linked list </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>the data you wish to store in the linked list</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the new node NULL on error</dd></dl>
note: the new node becomes the tail 
</div>
</div><p>
<a class="anchor" name="776a86890036e203e4ce88181e9abc7d"></a><!-- doxytag: member="CLList.h::CLList_append_list" ref="776a86890036e203e4ce88181e9abc7d" args="(CLList *dest, CLList *src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CLList_append_list           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCLList.html">CLList</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCLList.html">CLList</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
function to move another double linked list to the tail of a circular linked list<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>the linked list you want to move the src to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>the linked list you want to move to the dest</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>nothing</dd></dl>
notes: you can cast a <a class="el" href="structQLList.html">QLList</a>, or <a class="el" href="structDQLList.html">DQLList</a> or <a class="el" href="structDLList.html">DLList</a> to <a class="el" href="structCLList.html">CLList</a> for the src argument the head becomes the head of dest if dest is not empty, otherwise head becomes the head of src 
</div>
</div><p>
<a class="anchor" name="3bafa40bd49e3ea57ef0b5cb897fcf83"></a><!-- doxytag: member="CLList.h::CLList_append_list_copy" ref="3bafa40bd49e3ea57ef0b5cb897fcf83" args="(CLList *dest, CLList *src, CLList_data_copy_func copy_func)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCLList__node__tab.html">CLList_node</a>* CLList_append_list_copy           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCLList.html">CLList</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCLList.html">CLList</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="CLList_8h.html#3d605c8a96cd6648f2c8a48438efd6eb">CLList_data_copy_func</a>&nbsp;</td>
          <td class="paramname"> <em>copy_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
function to copy another list to the tail of a circular linked list<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>the linked list you want to copy the src to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>the linked list you want to copy to the dest </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>copy_func</em>&nbsp;</td><td>function to copy the data held in each node</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>null on success the src node we were trying to copy when malloc failed</dd></dl>
notes: you can cast a <a class="el" href="structSLList.html">SLList</a>, <a class="el" href="structstackLList.html">stackLList</a> , <a class="el" href="structQLList.html">QLList</a>, <a class="el" href="structDQLList.html">DQLList</a>, or <a class="el" href="structDLList.html">DLList</a> to <a class="el" href="structCLList.html">CLList</a> for the src argument the head becomes the head of dest if dest is not empty, otherwise head becomes the head of src 
</div>
</div><p>
<a class="anchor" name="35f655beb932d5685ed4adf55ba579d9"></a><!-- doxytag: member="CLList.h::CLList_delete" ref="35f655beb932d5685ed4adf55ba579d9" args="(CLList *list, CLList_node *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* CLList_delete           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCLList.html">CLList</a> *&nbsp;</td>
          <td class="paramname"> <em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCLList__node__tab.html">CLList_node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
function to delete a node from a circular linked list<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>list</em>&nbsp;</td><td>the linked list </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>node</em>&nbsp;</td><td>the node you wish to delete</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the data the node held</dd></dl>
note: the head becomes the next node 
</div>
</div><p>
<a class="anchor" name="26b9eed51a08149d99a6ed6d6cd27f12"></a><!-- doxytag: member="CLList.h::CLList_delete_after" ref="26b9eed51a08149d99a6ed6d6cd27f12" args="(CLList *list, CLList_node *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* CLList_delete_after           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCLList.html">CLList</a> *&nbsp;</td>
          <td class="paramname"> <em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCLList__node__tab.html">CLList_node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
function to delete the node after a node in a circular linked list<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>list</em>&nbsp;</td><td>the linked list </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>node</em>&nbsp;</td><td>the node before the node you wish to delete</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the data the node held</dd></dl>
note: the node becomes the tail 
</div>
</div><p>
<a class="anchor" name="406fb5b9723d9ddb6caa0aafdf27a327"></a><!-- doxytag: member="CLList.h::CLList_delete_all" ref="406fb5b9723d9ddb6caa0aafdf27a327" args="(CLList *list, CLList_data_free_func function)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CLList_delete_all           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCLList.html">CLList</a> *&nbsp;</td>
          <td class="paramname"> <em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="CLList_8h.html#f6c6ca2fb5379cc18f8af44423622f2d">CLList_data_free_func</a>&nbsp;</td>
          <td class="paramname"> <em>function</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
function to delete all the nodes in a circular linked list<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>list</em>&nbsp;</td><td>the linked list </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>function</em>&nbsp;</td><td>the function to call to free the data</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>nothing </dd></dl>

</div>
</div><p>
<a class="anchor" name="4f31db7585de0125e2e720292c98257d"></a><!-- doxytag: member="CLList.h::CLList_delete_before" ref="4f31db7585de0125e2e720292c98257d" args="(CLList *list, CLList_node *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* CLList_delete_before           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCLList.html">CLList</a> *&nbsp;</td>
          <td class="paramname"> <em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCLList__node__tab.html">CLList_node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
function to delete the node before a node in a circular linked list<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>list</em>&nbsp;</td><td>the linked list </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>node</em>&nbsp;</td><td>the node after the node you wish to delete</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the data the node held</dd></dl>
note: the node becomes the head 
</div>
</div><p>
<a class="anchor" name="430db45e90d081c4553bfa00198b7bab"></a><!-- doxytag: member="CLList.h::CLList_insert_after" ref="430db45e90d081c4553bfa00198b7bab" args="(CLList *list, CLList_node *node, void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCLList__node__tab.html">CLList_node</a>* CLList_insert_after           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCLList.html">CLList</a> *&nbsp;</td>
          <td class="paramname"> <em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCLList__node__tab.html">CLList_node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
function to add a node after any node in a circular linked list<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>list</em>&nbsp;</td><td>the linked list </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>node</em>&nbsp;</td><td>the node you wish to place the new node after </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>the data you wish to store in the linked list</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the new node NULL on error</dd></dl>
note: if node is null or the list is empty the new node will be appended to the list the new node becomes the tail 
</div>
</div><p>
<a class="anchor" name="61401e0395828f9b11ebb81e12dc58b8"></a><!-- doxytag: member="CLList.h::CLList_insert_before" ref="61401e0395828f9b11ebb81e12dc58b8" args="(CLList *list, CLList_node *node, void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCLList__node__tab.html">CLList_node</a>* CLList_insert_before           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCLList.html">CLList</a> *&nbsp;</td>
          <td class="paramname"> <em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCLList__node__tab.html">CLList_node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
function to add a node before any node in a circular linked list<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>list</em>&nbsp;</td><td>the linked list </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>node</em>&nbsp;</td><td>the node you wish to place the new node before </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>the data you wish to store in the linked list</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the new node NULL on error</dd></dl>
note: if node is null or the list is empty the new node will be appended to the list the new node becomes the tail 
</div>
</div><p>
<a class="anchor" name="8e2cb7914972a92c26187178e71118af"></a><!-- doxytag: member="CLList.h::CLList_insert_list_after" ref="8e2cb7914972a92c26187178e71118af" args="(CLList *dest, CLList *src, CLList_node *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CLList_insert_list_after           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCLList.html">CLList</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCLList.html">CLList</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCLList__node__tab.html">CLList_node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
function to move another double linked list to the middle of a circular linked list, after a particular node<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>the linked list you want to move the src to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>the linked list you want to move to the dest </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>node</em>&nbsp;</td><td>the node you wish to insert src after</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>nothing</dd></dl>
notes: you can cast a <a class="el" href="structQLList.html">QLList</a>, or <a class="el" href="structDQLList.html">DQLList</a> or <a class="el" href="structDLList.html">DLList</a> to <a class="el" href="structCLList.html">CLList</a> for the src argument if node is null src is appended to dest the head becomes the node after node if node is not null, otherwise the head becomes the head of dest if dest is not empty, otherwise head becomes the head of src 
</div>
</div><p>
<a class="anchor" name="1f8b819b54c62977d88f2fab9988d5a2"></a><!-- doxytag: member="CLList.h::CLList_insert_list_after_copy" ref="1f8b819b54c62977d88f2fab9988d5a2" args="(CLList *dest, CLList *src, CLList_node *node, CLList_data_copy_func copy_func)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCLList__node__tab.html">CLList_node</a>* CLList_insert_list_after_copy           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCLList.html">CLList</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCLList.html">CLList</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCLList__node__tab.html">CLList_node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="CLList_8h.html#3d605c8a96cd6648f2c8a48438efd6eb">CLList_data_copy_func</a>&nbsp;</td>
          <td class="paramname"> <em>copy_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
function to copy another list to the middle of a circular linked list, after a particular node<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>the linked list you want to copy the src to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>the linked list you want to copy to the dest </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>node</em>&nbsp;</td><td>the dest node you wish to copy the data after </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>copy_func</em>&nbsp;</td><td>function to copy the data held in each node</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>null on success the src node we were trying to copy when malloc failed</dd></dl>
notes: you can cast a <a class="el" href="structSLList.html">SLList</a>, <a class="el" href="structstackLList.html">stackLList</a> , <a class="el" href="structQLList.html">QLList</a>, <a class="el" href="structDQLList.html">DQLList</a>, or <a class="el" href="structDLList.html">DLList</a> to <a class="el" href="structCLList.html">CLList</a> for the src argument the head becomes the node after node if node is not null, otherwise the head becomes the head of dest if dest is not empty, otherwise head becomes the head of src 
</div>
</div><p>
<a class="anchor" name="b1e4bb108f2c79fabb2396fb09d56891"></a><!-- doxytag: member="CLList.h::CLList_insert_list_before" ref="b1e4bb108f2c79fabb2396fb09d56891" args="(CLList *dest, CLList *src, CLList_node *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CLList_insert_list_before           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCLList.html">CLList</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCLList.html">CLList</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCLList__node__tab.html">CLList_node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
function to move another double linked list to the middle of a circular linked list, before a particular node<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>the linked list you want to move the src to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>the linked list you want to move to the dest </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>node</em>&nbsp;</td><td>the node you wish to insert src before</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>nothing</dd></dl>
notes: you can cast a <a class="el" href="structQLList.html">QLList</a>, or <a class="el" href="structDQLList.html">DQLList</a> or <a class="el" href="structDLList.html">DLList</a> to <a class="el" href="structCLList.html">CLList</a> for the src argument if node is null src is appended to dest the head becomes node if node is not null, otherwise the head becomes the head of dest if dest is not empty, otherwise head becomes the head of src 
</div>
</div><p>
<a class="anchor" name="49451808cf3a6da23d9eb256b4ed34d0"></a><!-- doxytag: member="CLList.h::CLList_insert_list_before_copy" ref="49451808cf3a6da23d9eb256b4ed34d0" args="(CLList *dest, CLList *src, CLList_node *node, CLList_data_copy_func copy_func)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCLList__node__tab.html">CLList_node</a>* CLList_insert_list_before_copy           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCLList.html">CLList</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCLList.html">CLList</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCLList__node__tab.html">CLList_node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="CLList_8h.html#3d605c8a96cd6648f2c8a48438efd6eb">CLList_data_copy_func</a>&nbsp;</td>
          <td class="paramname"> <em>copy_func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
function to copy another list to the middle of a circular linked list, before a particular node<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>the linked list you want to copy the src to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>the linked list you want to copy to the dest </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>node</em>&nbsp;</td><td>the dest node you wish to copy the data before </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>copy_func</em>&nbsp;</td><td>function to copy the data held in each node</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>null on success the src node we were trying to copy when malloc failed</dd></dl>
notes: you can cast a <a class="el" href="structSLList.html">SLList</a>, <a class="el" href="structstackLList.html">stackLList</a> , <a class="el" href="structQLList.html">QLList</a>, <a class="el" href="structDQLList.html">DQLList</a>, or <a class="el" href="structDLList.html">DLList</a> to <a class="el" href="structCLList.html">CLList</a> for the src argument the head becomes node if node is not null, otherwise the head becomes the head of dest if dest is not empty, otherwise head becomes the head of src 
</div>
</div><p>
<a class="anchor" name="e6e71ca1a8f11e148498a0ad30647d14"></a><!-- doxytag: member="CLList.h::CLList_iterate" ref="e6e71ca1a8f11e148498a0ad30647d14" args="(CLList *list, CLList_iterate_func function, void *extra)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* CLList_iterate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCLList.html">CLList</a> *&nbsp;</td>
          <td class="paramname"> <em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="CLList_8h.html#14195b0568a72a7b6703d5c5c082def5">CLList_iterate_func</a>&nbsp;</td>
          <td class="paramname"> <em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>extra</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
function to iterate a circular linked list<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>list</em>&nbsp;</td><td>the linked list </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>function</em>&nbsp;</td><td>the function to pass each node to for processing </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>extra</em>&nbsp;</td><td>extra data to pass to/from the proccessing function</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the non null returned from the proccessing function that stops the iteration NULL if the end of the linked list was reached</dd></dl>
note: if the proccessing function does not return NULL the tail becomes the current node 
</div>
</div><p>
<a class="anchor" name="a075ee2c83a1cc2378677dc04280cad9"></a><!-- doxytag: member="CLList.h::CLList_length" ref="a075ee2c83a1cc2378677dc04280cad9" args="(CLList *list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t CLList_length           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCLList.html">CLList</a> *&nbsp;</td>
          <td class="paramname"> <em>list</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
function to count the nodes in a circular linked list<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>list</em>&nbsp;</td><td>the linked list</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of nodes in the linked list </dd></dl>

</div>
</div><p>
<a class="anchor" name="3fa053da617f5c5a39a62ffeaeac69bd"></a><!-- doxytag: member="CLList.h::CLList_rotate" ref="3fa053da617f5c5a39a62ffeaeac69bd" args="(CLList *list, size_t nodes, int reverse)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CLList_rotate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCLList.html">CLList</a> *&nbsp;</td>
          <td class="paramname"> <em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>reverse</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
function to rotate the Circular linked list<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>list</em>&nbsp;</td><td>the linked list </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nodes</em>&nbsp;</td><td>the number of nodes to rotate the linked list </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reverse</em>&nbsp;</td><td>non zero value to reverse the rotation</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>nothing</dd></dl>
note: if the number of nodes is greater than or equal to the number of nodes in the list head, and tail will be simply swapped 
</div>
</div><p>
<hr size="1"><address style="text-align: right;"><small>Generated on Sun Feb 15 09:44:45 2009 for libDataStruct by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.4 </small></address>
</body>
</html>
